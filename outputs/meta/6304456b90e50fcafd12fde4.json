{
  "code_links": [
    "None"
  ],
  "tasks": [
    "Software verification",
    "Automated program proof",
    "Failed proof analysis"
  ],
  "datasets": [
    "None"
  ],
  "methods": [
    "Proof2Test tool",
    "SMT solver",
    "Boogie",
    "AutoProof system"
  ],
  "results": [
    "None"
  ],
  "paper_id": "6304456b90e50fcafd12fde4",
  "title": "A Failed Proof Can Yield a Useful Test",
  "abstract": "  A successful automated program proof is, in software verification, the ultimate triumph. In practice, however, the road to such success is paved with many failed proof attempts. Unlike a failed test, which provides concrete evidence of an actual bug in the program, a failed proof leaves the programmer in the dark. Can we instead learn something useful from it?   The work reported here takes advantage of the rich internal information that some automatic provers collect about the program when attempting a proof. If the proof fails, the Proof2Test tool presented in this article uses the counterexample generated by the prover (specifically, the SMT solver underlying the proof environment Boogie, used in the AutoProof system to perform correctness proofs of contract-equipped Eiffel programs) to produce a failed test, which provides the programmer with immediately exploitable information to correct the program. The discussion presents the Proof2Test tool and demonstrates the application of the ideas and tool to a collection of representative examples. "
}