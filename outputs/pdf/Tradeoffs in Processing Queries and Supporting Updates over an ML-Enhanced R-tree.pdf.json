{
  "code_links": [
    "None"
  ],
  "tasks": [
    "Improving query processing performance in spatial databases"
  ],
  "datasets": [
    "UCR-STAR: Tweets location",
    "UCR-STAR: Gowalla",
    "UCR-STAR: Chicago crimes"
  ],
  "methods": [
    "AI+R-tree",
    "Multi-label classification",
    "Custom loss function"
  ],
  "results": [
    "Up to 5.4X improvement in query processing time for high-overlap range queries",
    "Up to 99% average query recall",
    "Custom loss function improves recall with lower latency"
  ],
  "title": "Tradeoffs in Processing Queries and Supporting Updates over an ML-Enhanced R-tree.pdf",
  "abstract": "\u2014Machine Learning (ML) techniques have been suc- cessfully applied to design various learned database index struc- tures for both the one- and multi-dimensional spaces. Particu- larly, a class of traditional multi-dimensional indexes has been augmented with ML models to design ML-enhanced variants of their traditional counterparts. This paper focuses on the R-tree multi-dimensional index structure as it is widely used for indexing multi-dimensional data. The R-tree has been augmented with machine learning models to enhance the R-tree performance. The AI+R-tree is an ML-enhanced R-tree index structure that augments a traditional disk-based R-tree with an ML model to enhance the R-tree\u2019s query processing performance, mainly, to avoid navigating the overlapping branches of the R-tree that do not yield query results, e.g., in the presence of high-overlap among the rectangles of the R-tree nodes. We investigate the empirical tradeoffs in processing dynamic query workloads and and in supporting updates over the AI+R-tree. Particularly, we investigate the impact of the choice of ML models over the AI+R-tree query processing performance. Moreover, we present a case study of designing a custom loss function for a neural network model tailored to the query processing requirements of the AI+R-tree. Furthermore, we present the design tradeoffs for adopting various strategies for supporting dynamic inserts, updates, and deletes with the vision of realizing a mutable AI+R-tree. Experiments on real datasets demonstrate that the AI+R-tree can enhance the query processing performance of a traditional R-tree for high-overlap range queries by up to 5.4X while achieving up to 99% average query recall. Index Terms\u2014Machine Learning for Database Systems, Learned Indexes, Spatial Indexing, Query Processing I. INTRODUCTION Recently, machine learning techniques (ML techniques, for short) have been successfully applied to build various learned database system components [1]. Particularly, ML techniques have been applied to database indexes to build learned index structures, e.g., [2]\u2013[5] for the one-dimensional space. The concept of learned one-dimensional learned indexes has been extended to realize learned multi-dimensional indexes [6]\u2013 [10]. Moreover, learned indexes can be broadly categorized into two types: Pure and Hybrid learned indexes [10]. The core idea behind the class of hybrid learned indexes is that they incorporate ML models to enhance the performance of a traditional index structure [11], [12]. These hybrid learned indexes can also be viewed as ML-enhanced variants of their traditional counterparts. On the other hand, traditional multi-dimensional (e.g., spatial) index structures have been used successfully over the years as efficient access methods for multi-dimensional data (e.g., location data). In the area of spatial databases, the R-tree [13] is a widely-used index structure. In the Fig. 1. An example of an R-tree with overlapping nodes multi-dimensional space, the R-tree is analogous to the one- dimensional index structure B+-tree [14]. In the R-tree, objects are stored using Minimum Bounding Rectangles (MBRs). Notice that in the B+-tree, nodes do not overlap in space. However, the MBRs of non-leaf and leaf nodes of an R-tree can overlap in space. In this paper, we focus on processing range queries over an R-tree due to their wide applicability in spatial databases [15]. Figure 1 illustrates the impact of node overlap in an R-tree to answer a range query. Notice that the number of accessed leaf nodes directly impacts the query response time of an R- tree [15]. For a disk-based R-tree, descending multiple paths in the R-tree incurs high I/O cost [16]. In Figure 1, the leaf nodes of the R-tree are labeled R7-R14. Consider Range Queries Q1, Q2, and Q3. For Q1, we search the R-tree down the 2 paths (from root to leaf): R1 \u2192R5 \u2192R12 and R1 \u2192R5 \u2192R13 while only the latter path contains actual query results. Hence, accessing the leaf node R12 is wasted. For Q2, we search the R-tree along 4 paths: R1 \u2192R5 \u2192R13, R2 \u2192R4 \u2192R10, R2 \u2192R6 \u2192R11, and R2 \u2192R6 \u2192R14 while only the 2nd and 4th paths contain output data objects. Hence, accessing the leaf nodes R11 and R13 negatively impacts query processing performance. For Query Q3, the R-tree searches two paths: R1 \u2192R3 \u2192R7 and R1 \u2192R3 \u2192R8, where both paths contain output data objects. In both Q1 and Q2, the R-tree accesses 50% more leaf nodes than the true number of leaf nodes containing the output data objects. In contrast, for Query Q3, the R-tree searches both R7 and R8, and data objects are exactly found in both nodes. In this case, the number of visited leaf nodes by the R-tree matches the true number of leaf nodes required to answer Q3. Thus, in terms of the number of leaf node accesses, we can identify Q1 and Q2 as high-overlap queries and Q3 as a low-overlap query. Observe that the R-tree searches extraneous leaf nodes to answer Q1 or Q2 but performs optimally for Q3. We define an overlap ratio \u03b1 to quantify the degree of extraneous leaf node accesses arXiv:2502.09937v1 [cs.DB] 14 Feb 2025"
}