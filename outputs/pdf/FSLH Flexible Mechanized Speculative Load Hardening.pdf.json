{
  "code_links": [
    "None"
  ],
  "tasks": [
    "Speculative side-channel attacks"
  ],
  "datasets": [
    "None"
  ],
  "methods": [
    "Flexible SLH",
    "Selective SLH",
    "Ultimate SLH",
    "Speculative Load Hardening (SLH)",
    "Relative Security",
    "Formal Verification"
  ],
  "results": [
    "FSLH provides a flexible SLH notion generalizing both Selective and Ultimate SLH",
    "FSLH enforces a strong relative security property",
    "FSLH can be instantiated to recover both the corresponding Selective SLH variant as well as Ultimate SLH"
  ],
  "title": "FSLH Flexible Mechanized Speculative Load Hardening.pdf",
  "abstract": "\u2014The Spectre speculative side-channel attacks pose formidable threats for computer system security. Research has shown that cryptographic constant-time code can be efficiently protected against Spectre v1 using a selective variant of Spec- ulative Load Hardening (SLH). SLH was, however, not strong enough for protecting non-cryptographic code, leading to the introduction of Ultimate SLH, which provides protection for arbitrary programs, but has too large overhead for general use, since it conservatively assumes that all data is secret. In this paper we introduce a flexible SLH notion that achieves the best of both worlds by formally generalizing both Selective and Ultimate SLH. We give a suitable security definition for such transformations protecting arbitrary programs: any transformed program running with speculation should not leak more than what the source program leaks sequentially. We formally prove using the Rocq prover that two flexible SLH variants enforce this relative security guarantee. As easy corollaries we also obtain that Ultimate SLH enforces our relative security notion, and also that the selective variants of value SLH and address SLH enforce speculative constant-time security. Keywords\u2014side-channel attacks, speculative execution, Spec- tre, secure compilation, speculative load hardening, speculative constant time, relative security, formal verification, Rocq, Coq 1 Introduction Speculative side-channel attacks such as Spectre pose formidable threats for the security of computer systems [8, 19]. For instance, in typical Spectre v1 attacks [18], misspeculated array bounds checks cause out-of-bounds memory accesses to inadvertently load and reveal secrets via timing variations. SLH [9] is a software countermeasure against such attacks, originally proposed and implemented by LLVM, that dynam- ically tracks whether execution is in a mispredicted branch using a misspeculation flag register. This misspeculation flag is used as a mask to erase the value of any misspeculated loads, in a variant Zhang et al. [26] denote as vSLH, for value SLH. Another variant supported by LLVM is to mask the address of any misspeculated loads, which also following Zhang et al., we denote as aSLH, for address SLH. It is, however, challenging to build software protections that are both efficient and that provide formal end-to-end security guarantees against precisely specified, speculative side-channel attacker models [12]. Cryptography researchers are leading the way in this space, with defenses such as selective vSLH effi- ciently achieving speculative constant-time guarantees against Spectre v1 for cryptographic code with typical overheads under 1% [22, 23]. This work is, however, specialized to only cryptographic code and often also to domain-specific languages for cryptography, such as Jasmin [2]. It is more difficult to properly protect arbitrary programs written in general-purpose languages, which in particular do not obey the cryptographic constant-time discipline [1, 10]. SLH was not strong enough for protecting such non- cryptographic code [20], leading to the introduction of Ulti- mate SLH [20, 26], which uses the misspeculation flag to mask not only the values loaded from memory, but also all branch conditions, all memory addresses, the operands of all non- constant time operations, etc. While this should in principle be strong enough to achieve a relative security notion [12, 20, 26], it also brings \u223c150% overhead on the SPEC benchmarks [26], which seems unacceptable for many practical scenarios. In this paper we introduce FSLH, a flexible SLH notion that achieves the best of both worlds by generalizing both Selective and Ultimate SLH. Like Selective SLH, FSLH keeps track of which program inputs are secret and which ones not and only protects those memory operations that could potentially leak secret inputs when ran speculatively. Like Ultimate SLH, FSLH also provides protection for non-cryptographic code that does not respect the constant-time discipline, but does this by only masking those branch conditions and memory addresses that are potentially influenced by secrets. Contributions \u25b6We introduce FSLH, a Flexible SLH notion generalizing both Selective SLH and Ultimate SLH. This applies to both vSLH and aSLH, resulting in two variants: Flexible value SLH (FvSLH) and Flexible address SLH (FaSLH). \u25b6We prove formally in the Rocq prover1 that FvSLH and FaSLH can each be instantiated to recover both the corre- sponding Selective SLH variant as well as Ultimate SLH. The connection to Selective SLH guarantees that cryp- tographic constant-time code pays no extra performance penalty under Flexible SLH compared to Selective SLH. The connection to Ultimate SLH states that if all data is labeled as secret then the program receives the same protection as with Ultimate SLH. \u25b6We give a suitable relative security definition for trans- formations protecting arbitrary programs, like FSLH and Ultimate SLH: any transformed program running with speculation should not leak more than what the source program leaks sequentially (so without speculation). \u25b6We prove in Rocq that our two flexible SLH variants, FvSLH and FaSLH, enforce this relative security notion. \u25b6As a corollary we obtain in Rocq that Ultimate SLH also enforces relative security, which is, the first machine- checked security proof for Ultimate SLH [20, 26]. \u25b6Other easy corollaries we obtain in Rocq are that Selective vSLH and Selective aSLH enforce speculative constant- time security, whereas previously only Selective vSLH was proved secure and only on paper [22]. In fact, for Selective 1The Rocq interactive theorem prover was previously known as Coq. arXiv:2502.03203v3 [cs.CR] 13 Feb 2025"
}